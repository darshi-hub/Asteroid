<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CodePilot 3D Asteroid Shooter</title>
    <style>
        /* Mobile-first and Tailwind-inspired aesthetic */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d1117; /* Dark space background */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: #ffffff;
        }
        canvas {
            display: block;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to fall through to canvas unless on a UI element */
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 1rem;
            box-sizing: border-box;
            z-index: 10;
        }
        #score-display {
            position: absolute;
            top: 1rem;
            left: 1rem;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-shadow: 0 0 10px #00aaff;
        }

        /* --- Virtual Joystick & Fire Button (Mobile Controls) --- */
        #mobile-controls {
            display: none; /* Default to hidden for desktop */
            pointer-events: auto;
        }

        @media (max-width: 768px) { /* Show on mobile/tablet screens like iPad */
            #mobile-controls {
                display: flex;
                width: 100%;
                justify-content: space-between;
                align-items: flex-end;
            }
        }

        /* Joystick Container */
        #joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(45, 49, 56, 0.4);
            border-radius: 50%;
            border: 2px solid rgba(139, 148, 158, 0.5);
            position: relative;
            touch-action: none;
            cursor: pointer;
        }

        /* Joystick Knob */
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(0, 170, 255, 0.7);
            border-radius: 50%;
            border: 2px solid #00aaff;
        }

        /* Fire Button */
        #fire-button {
            width: 80px;
            height: 80px;
            background: rgba(255, 50, 50, 0.7);
            border-radius: 50%;
            border: 3px solid #ff0000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #ffffff;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
            transition: background 0.1s;
        }
        #fire-button:active {
            background: #ff3232;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="ui-overlay">
        <div id="score-display">SCORE: 0</div>
        <div id="mobile-controls">
            <div id="joystick-container">
                <div id="joystick-knob"></div>
            </div>
            <div id="fire-button">FIRE</div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, light;
        let ship, shipVelocity = new THREE.Vector3();
        const shipSpeed = 0.2;
        const rotationSpeed = 0.05;
        let bullets = [];
        let asteroids = [];
        let score = 0;
        let lastFireTime = 0;
        const fireRate = 200; // ms between shots
        const fieldSize = 100;

        // Input state for keyboard and joystick
        let keys = { w: false, a: false, d: false, space: false };
        let joystick = { active: false, x: 0, y: 0 };
        const deadZone = 0.1;

        /**
         * Procedurally creates the player spaceship model.
         * The model is constructed from a fuselage, cockpit, and two engines (all basic geometries).
         */
        function createShip() {
            const shipGroup = new THREE.Group();

            // 1. Fuselage (Procedural Box)
            const fuselageGeometry = new THREE.BoxGeometry(1, 1, 3);
            const fuselageMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.4,
                emissive: 0x000000
            });
            const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
            shipGroup.add(fuselage);

            // 2. Cockpit (Procedural Cone)
            const cockpitGeometry = new THREE.ConeGeometry(0.7, 1.5, 8);
            const cockpitMaterial = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                metalness: 0.1,
                roughness: 0.1,
                emissive: 0x004488
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.rotation.x = Math.PI / 2; // Point forward
            cockpit.position.z = 1.5 + 0.75;
            shipGroup.add(cockpit);

            // 3. Engine Thrusters (Simple Emissive Cylinders)
            const engineGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
            const engineMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                metalness: 0.9,
                roughness: 0.1
            });

            const engineL = new THREE.Mesh(engineGeometry, engineMaterial);
            engineL.position.set(-0.8, 0, -1.5);
            engineL.rotation.x = Math.PI / 2;
            shipGroup.add(engineL);

            const engineR = new THREE.Mesh(engineGeometry, engineMaterial);
            engineR.position.set(0.8, 0, -1.5);
            engineR.rotation.x = Math.PI / 2;
            shipGroup.add(engineR);

            // Set the ship to face down the Z-axis initially
            shipGroup.rotation.y = Math.PI;

            return shipGroup;
        }

        /**
         * Procedurally creates an asteroid geometry by deforming an Icosahedron.
         * @returns {THREE.Mesh} The procedural asteroid mesh.
         */
        function createAsteroidMesh() {
            // Start with a basic Icosahedron for a smooth base
            const geometry = new THREE.IcosahedronGeometry(1, 1);
            const position = geometry.attributes.position;
            const vertex = new THREE.Vector3();

            // Randomly displace vertices to create a rugged, non-uniform look
            for (let i = 0; i < position.count; i++) {
                vertex.fromBufferAttribute(position, i);
                const magnitude = 1 + (Math.random() - 0.5) * 0.4; // Displace by +/- 20%
                vertex.normalize().multiplyScalar(magnitude);
                position.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }

            geometry.computeVertexNormals();
            geometry.attributes.position.needsUpdate = true;

            const material = new THREE.MeshStandardMaterial({
                color: 0x5c5470, // Gray/rock color
                metalness: 0.3,
                roughness: 0.8,
            });

            const mesh = new THREE.Mesh(geometry, material);
            const scale = Math.random() * 3 + 2; // Asteroids range from 2 to 5 in size
            mesh.scale.set(scale, scale, scale);
            mesh.userData.health = scale; // Health based on size
            mesh.userData.isAsteroid = true;
            mesh.userData.rotationSpeed = new THREE.Vector3(
                Math.random() * 0.01 - 0.005,
                Math.random() * 0.01 - 0.005,
                Math.random() * 0.01 - 0.005
            );
            return mesh;
        }

        /**
         * Spawns a new asteroid at a random position outside the central play area.
         */
        function spawnAsteroid() {
            const asteroid = createAsteroidMesh();
            const posSign = Math.random() < 0.5 ? 1 : -1;
            const posScale = fieldSize / 2;

            // Randomly position outside the field, preferring the edges
            asteroid.position.x = (Math.random() * 2 - 1) * posScale;
            asteroid.position.y = (Math.random() * 2 - 1) * posScale;
            asteroid.position.z = (Math.random() * 2 - 1) * posScale;

            // Ensure it's far enough from the center
            if (asteroid.position.length() < fieldSize / 4) {
                // If too close, push it out along a random axis
                const axis = Math.floor(Math.random() * 3);
                if (axis === 0) asteroid.position.x = posSign * posScale;
                if (axis === 1) asteroid.position.y = posSign * posScale;
                if (axis === 2) asteroid.position.z = posSign * posScale;
            }

            // Direction vector towards the center
            const direction = new THREE.Vector3(0, 0, 0).sub(asteroid.position).normalize();
            asteroid.userData.velocity = direction.multiplyScalar(Math.random() * 0.05 + 0.05);

            asteroids.push(asteroid);
            scene.add(asteroid);
        }

        /**
         * Creates and launches a bullet from the ship's current position and direction.
         */
        function fireBullet() {
            const currentTime = performance.now();
            if (currentTime - lastFireTime < fireRate) return;
            lastFireTime = currentTime;

            // Procedural Bullet (Simple Sphere)
            const geometry = new THREE.SphereGeometry(0.2, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                wireframe: false,
                transparent: true,
                opacity: 0.8
            });
            const bullet = new THREE.Mesh(geometry, material);

            // Set bullet position to the ship's position
            bullet.position.copy(ship.position);

            // Calculate bullet velocity based on ship's forward direction
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyQuaternion(ship.quaternion);
            bullet.userData.velocity = forward.multiplyScalar(1.5);
            bullet.userData.isBullet = true;

            bullets.push(bullet);
            scene.add(bullet);
        }

        /**
         * Initializes the Three.js scene, camera, renderer, and lights.
         */
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0d1117, fieldSize / 2, fieldSize * 1.5);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, fieldSize * 2);
            camera.position.set(0, 5, -10); // Elevated and slightly behind the ship
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0d1117);
            document.body.appendChild(renderer.domElement);

            // --- Lighting ---
            // Key Light (Emphasizes ship and asteroids)
            light = new THREE.PointLight(0xffffff, 1.5, 100);
            scene.add(light);

            // Ambient Light (Soft fill)
            const ambient = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambient);

            // --- Game Objects ---
            ship = createShip();
            ship.position.z = 0;
            scene.add(ship);

            // Initial asteroid spawn
            for (let i = 0; i < 10; i++) {
                spawnAsteroid();
            }

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            setupMobileControls();

            // Start the game loop
            animate();
        }

        /**
         * Handles window resizing for responsiveness.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Updates the ship's position and rotation based on input.
         */
        function updateShip(delta) {
            // Apply rotation (A/D or Joystick X)
            let rotFactor = 0;
            if (keys.a) rotFactor += 1;
            if (keys.d) rotFactor -= 1;
            if (Math.abs(joystick.x) > deadZone) rotFactor -= joystick.x;

            ship.rotation.y += rotFactor * rotationSpeed;

            // Apply forward velocity (W or Joystick Y)
            let moveFactor = 0;
            if (keys.w) moveFactor += 1;
            if (Math.abs(joystick.y) > deadZone) moveFactor += joystick.y;

            if (moveFactor > 0) {
                // Calculate forward vector based on current rotation
                const forward = new THREE.Vector3(0, 0, 1);
                forward.applyQuaternion(ship.quaternion);

                // Add to ship velocity
                shipVelocity.add(forward.multiplyScalar(moveFactor * shipSpeed));
            }

            // Apply friction/drag to velocity
            shipVelocity.multiplyScalar(0.98);

            // Update ship position
            ship.position.add(shipVelocity);

            // Warp effect when leaving the field boundary
            if (Math.abs(ship.position.x) > fieldSize / 2) ship.position.x *= -1;
            if (Math.abs(ship.position.y) > fieldSize / 2) ship.position.y *= -1;
            if (Math.abs(ship.position.z) > fieldSize / 2) ship.position.z *= -1;

            // Keep the light positioned near the ship for consistent shading
            light.position.copy(ship.position);
            light.position.y += 10;
        }

        /**
         * Handles the movement of bullets and checks for collisions.
         */
        function updateBullets() {
            const nextBullets = [];
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];
                bullet.position.add(bullet.userData.velocity);

                let hit = false;
                for (let j = 0; j < asteroids.length; j++) {
                    const asteroid = asteroids[j];
                    if (bullet.position.distanceTo(asteroid.position) < asteroid.scale.x) {
                        // Collision detected
                        hit = true;
                        scene.remove(asteroid);
                        asteroids.splice(j, 1);
                        j--; // Decrement to stay on the correct index
                        score += 10;
                        document.getElementById('score-display').innerText = `SCORE: ${score}`;

                        // Spawn a new one to keep the difficulty steady
                        spawnAsteroid();
                        break;
                    }
                }

                // Remove bullet if it hit an asteroid or flew out of bounds
                if (hit || Math.abs(bullet.position.x) > fieldSize || Math.abs(bullet.position.y) > fieldSize || Math.abs(bullet.position.z) > fieldSize) {
                    scene.remove(bullet);
                } else {
                    nextBullets.push(bullet);
                }
            }
            bullets = nextBullets;
        }

        /**
         * Handles the movement and rotation of asteroids.
         */
        function updateAsteroids() {
            for (const asteroid of asteroids) {
                asteroid.position.add(asteroid.userData.velocity);

                // Rotate the asteroid
                asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
                asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
                asteroid.rotation.z += asteroid.userData.rotationSpeed.z;

                // Loop asteroid position when leaving the field
                if (Math.abs(asteroid.position.x) > fieldSize / 2) asteroid.position.x *= -1;
                if (Math.abs(asteroid.position.y) > fieldSize / 2) asteroid.position.y *= -1;
                if (Math.abs(asteroid.position.z) > fieldSize / 2) asteroid.position.z *= -1;

                // Simple Game Over Check (Ship/Asteroid Collision)
                if (ship.position.distanceTo(asteroid.position) < asteroid.scale.x + 1.5) {
                    // This is a simple visual indicator of game over
                    console.log("GAME OVER");
                    alert(`GAME OVER! Final Score: ${score}`);
                    // Reset game state
                    location.reload();
                    return;
                }
            }
        }

        /**
         * Main game loop (Animation Frame).
         */
        function animate() {
            requestAnimationFrame(animate);

            updateShip();
            updateBullets();
            updateAsteroids();

            // Handle continuous firing from the 'space' key or fire button
            if (keys.space) {
                fireBullet();
            }

            // Simple camera follow
            camera.position.x = ship.position.x;
            camera.position.z = ship.position.z - 10;
            camera.position.y = ship.position.y + 5;
            camera.lookAt(ship.position);

            renderer.render(scene, camera);
        }

        // --- Input Handling (Keyboard) ---
        function onKeyDown(event) {
            switch (event.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 'd': keys.d = true; break;
                case ' ': keys.space = true; event.preventDefault(); break; // Prevent space from scrolling
            }
        }

        function onKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
            }
        }

        // --- Input Handling (Mobile/Touch) ---
        function setupMobileControls() {
            const joystickContainer = document.getElementById('joystick-container');
            const joystickKnob = document.getElementById('joystick-knob');
            const fireButton = document.getElementById('fire-button');
            const maxRadius = joystickContainer.clientWidth / 2;

            function handleMove(e) {
                e.preventDefault();
                if (!joystick.active) return;

                const touch = e.touches ? e.touches[0] : e;
                const rect = joystickContainer.getBoundingClientRect();
                const center = { x: rect.left + maxRadius, y: rect.top + maxRadius };

                let dx = touch.clientX - center.x;
                let dy = touch.clientY - center.y;

                let distance = Math.sqrt(dx * dx + dy * dy);
                let angle = Math.atan2(dy, dx);

                if (distance > maxRadius) {
                    dx = Math.cos(angle) * maxRadius;
                    dy = Math.sin(angle) * maxRadius;
                    distance = maxRadius;
                }

                // Update knob position
                joystickKnob.style.left = `${maxRadius + dx}px`;
                joystickKnob.style.top = `${maxRadius + dy}px`;

                // Normalize and invert Y for game logic (Up is positive in game)
                joystick.x = dx / maxRadius;
                joystick.y = -(dy / maxRadius);
            }

            function handleUp() {
                joystick.active = false;
                joystickKnob.style.left = '50%';
                joystickKnob.style.top = '50%';
                joystick.x = 0;
                joystick.y = 0;
            }

            // Joystick Events
            joystickContainer.addEventListener('touchstart', (e) => {
                joystick.active = true;
                handleMove(e);
            }, false);
            joystickContainer.addEventListener('touchmove', handleMove, false);
            joystickContainer.addEventListener('touchend', handleUp, false);
            joystickContainer.addEventListener('touchcancel', handleUp, false);

            // Fire Button Events
            fireButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.space = true;
                fireBullet();
            }, false);
            fireButton.addEventListener('touchend', () => {
                keys.space = false;
            }, false);
        }

        // Start initialization
        window.onload = init;
    </script>
</body>
</html>
